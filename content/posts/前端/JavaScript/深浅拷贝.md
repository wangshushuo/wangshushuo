---
title: 深浅拷贝
url: /深浅拷贝.html
date: 2020-05-25T18:34:27+08:00
summary: 
categories:
- 算法
---

## 什么是拷贝，什么是深浅拷贝

在 JavaScript 中，变量中保存的是对象的引用。比如像下面这样的操作
```js
var a = 对象1;
var b = a;
```
a和b都在引用对象1，如果对对象1进行修改，则a和b两个变量都会受到影响。有时我们不希望出现修改a时b也受到影响，这时就要对对象进行拷贝操作来切换引用。比如
```js
var a = 对象1;
var b = 拷贝(a);
```

那么如何实现拷贝呢？

我们知道对象是由多个key和value组成的，所以拷贝就是创建一个新的对象，将旧对象的key和value拷贝到新对象中，让新旧对象的key和value都完全一样。













简单的实现使用递归遍历字段。但是会遇到循环引用的问题。解决循环引用问题需要用循环代替递归。

首先有一个原对象a 创建一个空对象b copy的过程就是遍历a，将a的key和value转移到b上。 当value的值是基本类型时，可以直接将它copy到b上。 但是当value的值不是基本类型，也就是对象时，不能将它直接复制到b，因为这是浅复制的操作。我们需要对它也进行copy的操作。 如果遇到value是对象就立刻进行copy的话，这是递归的做法。为了避免递归，我们可以先将这个子对象存起来，待当前对象遍历完以后，在对刚刚存起来的子对象进行遍历。 对于这个暂存的子对象，需要知道它的父对象和key，才能找到它应该被安置在哪里。 所以它暂存子对象的数据结构是这样的

```js
{
  parent: 子对象的父对象b,
  key: 子对象对应的key,
  value: 子对象
}
```

当遍历该子对象时，先在父对象上创建一个空对象，将遍历到的key和value复制到空对象上。如果又遇到value是对象，则重复上面的过程，直至没有value是对象。也就是存储子对象的数组为空。

对于拷贝一个对象的过程lodash使用的是「结构化克隆算法」[^1]，普通对象直接复制key和value，数组等其他对象使用相应的复制方法。

```js
// value 参数为原对象
function cloneLoop(oldObject) {
  // 新的空对象
  const root = {};

  // 存储子对象的数组
  const children = [
    {
      parent: root,
      key: undefined,
      value: oldObject,
    }
  ];

  // 如果children内有子对象，则将其copy
  while(children.length) {
    // 深度优先，如果使用shift()则是广度有限。
    const node = children.pop();
    const parent = node.parent;
    const key = node.key;
    const value = node.value;

    // 当key是undefined时，parent是{}，也就是刚开始
    // 当key不是undefined时，就是已经复制到子对象了，这时key肯定时有值的，
    // 需要把key对应的value初始化为空对象，后面的循环把子对象的 key 和 value 复制到空对象上。
    let res = parent;
    if (typeof key !== 'undefined') {
      res = parent[key] = {};
    }

    // 遍历子对象
    for(let k in value) {
      if (data.hasOwnProperty(k)) {
        // 如果value时对象，将子对象放入「子对象数组」中，待下一次while读取遍历
        if (typeof value[k] === 'object') {
          // 下一次循环
          children.push({
            parent: res,
            key: k,
            value: value[k],
          });
        } else {
          res[k] = value[k];
        }
      }
    }
  }
  return root;
}
```

[^1]: 结构化克隆算法MDN：https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm ↩︎

[^2]: 结构化克隆算法规范：https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal ↩︎