---
title: 深浅拷贝
url: /深浅拷贝.html
date: 2020-05-25T18:34:27+08:00
summary: 
categories:
- 算法
---

## 什么是拷贝，什么是深浅拷贝

在 JavaScript 中，变量中保存的是对象的引用。比如像下面这样的操作
```js
var a = 对象1;
var b = a;
```
a和b都在引用对象1，如果对对象1进行修改，则a和b两个变量都会受到影响，有时我们不希望出现这种情况，就要对对象进行拷贝操作来切换引用。比如
```js
var a = 对象1;
var b = 拷贝(a);
```

那么如何实现拷贝呢？

我们知道对象是由多个key和value组成的，所以拷贝就是创建一个新的对象，将旧对象的key和value拷贝到新对象中，让新旧对象的key和value完全一样。比如像下面这样
```js
Object.keys(对象1).forEach(key => {
  新对象[key] = 对象1[key];
})
```
如果所有的value都是基本类型[^1]，这样的操作没问题。但是如果value是引用类型[^2]就会出现新旧对象中都引用了一个对象的情况，也就是上文提到的a和b变量的问题。..如果想完全切断引用，就要对引用类型的value在进行一次拷贝..。对于是否需要完全切断引用就有了两种拷贝方式，需要完全切断引用的就是「深拷贝」，不需要的就是「浅拷贝」。

简单概括一下。

「浅拷贝」是只对对象的key和value进行一次遍历拷贝，不管内部的引用。

「深拷贝」要将对象内部的引用完全切断，对对象进行递归地拷贝。

## 如何实现深拷贝

先看一种实现方式

{{< highlight js "linenos=inline,hl_lines=8,linenostart=1" >}}
function clone(旧对象) {
  var 新对象 = {};
  Object.keys(旧对象).forEach(key => {
    var value = 旧对象[key];
    if(is基本类型(value)) {
      新对象[key] = 旧对象[key];
    } else {
      clone(value); // 递归
    }
  })
  return 新对象;
}
{{< / highlight >}}









---

简单的实现使用递归遍历字段。但是会遇到循环引用的问题。解决循环引用问题需要用循环代替递归。

```
首先有一个原对象a
创建一个空对象b 
copy的过程就是遍历a，将a的key和value转移到b上。 
  当value的值是基本类型时，
    可以直接将它copy到b上。 
  但是当value的值不是基本类型，也就是对象时，
    不能将它直接复制到b，因为这是浅复制的操作。
    我们需要对它也进行copy的操作。 
    如果遇到value是对象就立刻进行copy的话，这是递归的做法。为了避免递归，我们可以先将这个子对象存起来，待当前对象遍历完以后，在对刚刚存起来的子对象进行遍历。 
    对于这个暂存的子对象，需要知道它的父对象和key，才能找到它应该被安置在哪里。 
    所以它暂存子对象的数据结构是这样的
```

```js
{
  parent: 子对象的父对象b,
  key: 子对象对应的key,
  value: 子对象
}
```

当遍历该子对象时，先在父对象上创建一个空对象，将遍历到的key和value复制到空对象上。如果又遇到value是对象，则重复上面的过程，直至没有value是对象。也就是存储子对象的数组为空。

对于拷贝一个对象的过程lodash使用的是「结构化克隆算法」[^3]，普通对象直接复制key和value，数组等其他对象使用相应的复制方法。

```js
// value 参数为原对象
function cloneLoop(oldObject) {
  // 新的空对象
  const root = {};

  // 存储子对象的数组
  const children = [
    {
      parent: root,
      key: undefined,
      value: oldObject,
    }
  ];

  // 如果children内有子对象，则将其copy
  while(children.length) {
    // 深度优先，如果使用shift()则是广度有限。
    const node = children.pop();
    const parent = node.parent;
    const key = node.key;
    const value = node.value;

    // 当key是undefined时，parent是{}，也就是刚开始
    // 当key不是undefined时，就是已经复制到子对象了，这时key肯定时有值的，
    // 需要把key对应的value初始化为空对象，后面的循环把子对象的 key 和 value 复制到空对象上。
    let res = parent;
    if (typeof key !== 'undefined') {
      res = parent[key] = {};
    }

    // 遍历子对象
    for(let k in value) {
      if (data.hasOwnProperty(k)) {
        // 如果value时对象，将子对象放入「子对象数组」中，待下一次while读取遍历
        if (typeof value[k] === 'object') {
          // 下一次循环
          children.push({
            parent: res,
            key: k,
            value: value[k],
          });
        } else {
          res[k] = value[k];
        }
      }
    }
  }
  return root;
}
```

[^1]: 基本类型有五种：String、Number、Boolean、Undefined和Null。
[^2]: 引用类型就是对象。
[^3]: 结构化克隆算法MDN：<https://developer.mozilla.org/zh-CN/docs/Web/Guide/API/DOM/The_structured_clone_algorithm>  
    结构化克隆算法规范：<https://html.spec.whatwg.org/multipage/structured-data.html#structuredserializeinternal>